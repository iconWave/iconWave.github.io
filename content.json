{"meta":{"title":"iconWave","subtitle":"web and poetry","description":"人生除了代码还有诗和远方。","author":"iconWave","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2015-10-19T22:49:50.000Z","updated":"2017-06-14T08:25:58.463Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2015-10-19T22:49:50.000Z","updated":"2017-06-14T08:10:12.638Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"eslint简单使用","slug":"eslint简单使用","date":"2017-03-20T14:48:00.000Z","updated":"2017-06-18T10:34:33.093Z","comments":true,"path":"2017/03/20/eslint简单使用/","link":"","permalink":"http://yoursite.com/2017/03/20/eslint简单使用/","excerpt":"#eslint简单使用 开始eslint是在 ECMAScript/JavaScript 代码中识别和报告模式匹配的工具，它的目标是保证代码的一致性和避免错误。（官方翻译）","text":"#eslint简单使用 开始eslint是在 ECMAScript/JavaScript 代码中识别和报告模式匹配的工具，它的目标是保证代码的一致性和避免错误。（官方翻译）两种安装方式 全局适用于所有项目文件 先全局安装 ESLint插件1$ npm install -g eslint 初始化配置文件1eslint --init 使用1eslint file.js 本地项目里使用 1$ npm install eslint -S react plugins 1$ npm install -S eslint-plugin-react 目前项目中使用的 airbnb 代码规范 1$ npm install -S eslint-config-airbnb 项目中初始化配置文件 1./node_modules/.bin/eslint --init 然后选择使用airbnb的方式 123? How would you like to configure ESLint? Use a popular style guide? Which style guide do you want to follow? AirBnB? What format do you want your config file to be in? JavaScript 运行 1./node_modules/.bin/eslint file.js autofix 只支持空格分号等链接","categories":[{"name":"eslint代码检查工具","slug":"eslint代码检查工具","permalink":"http://yoursite.com/categories/eslint代码检查工具/"}],"tags":[{"name":"eslint代码检查工具","slug":"eslint代码检查工具","permalink":"http://yoursite.com/tags/eslint代码检查工具/"}]},{"title":"redux之store","slug":"redux之reducer","date":"2016-09-19T15:48:00.000Z","updated":"2017-06-18T10:54:16.142Z","comments":true,"path":"2016/09/19/redux之reducer/","link":"","permalink":"http://yoursite.com/2016/09/19/redux之reducer/","excerpt":"redux之reducerreducer 为什么叫reducer大概是由于reducer函数都能作为数组的 reducer 方法的参数，所以叫 reducer 的把。 Array中的reducerreduce需要两个参数，一个是回调函数，一个是初始值，没有初始值，会默认把数组第一个当初始值，并从第二个开始","text":"redux之reducerreducer 为什么叫reducer大概是由于reducer函数都能作为数组的 reducer 方法的参数，所以叫 reducer 的把。 Array中的reducerreduce需要两个参数，一个是回调函数，一个是初始值，没有初始值，会默认把数组第一个当初始值，并从第二个开始 模拟数组的 reduce 方法 1234567891011121314Array.prototype.reduce = function reduce (callback, init) &#123; var i = 0; if(typeof init === &apos;undefined&apos;) &#123; init = this[0]; i = 1; &#125; if(typeof callback !== &apos;function&apos;) &#123; throw new Error(callback + &apos; is not function&apos;) &#125; for( ;i&lt; this.length; i++ ) &#123; init = callback(init, this[i]) &#125; return init ;&#125; reduce的使用 123456var ary = [1,2,3];console.log(ary.reduce((initialValue, next) =&gt; &#123; console.log(initialValue, next); return next;&#125;,0))// 01 12 23 3 写一个简单的 reducer 12345678910111213function reducer (initialValue, next) &#123; console.log(initialValue, next) switch (next) &#123; case 1: return next; break; default: return initialValue &#125;&#125;// 这个reducer 判断传入的值next。是1 的话 返回结果是 next 也就是1 ，所以最后结果都是1console.log(ary.reduce(reducer))// 12 13 1 reducer在redux中的作用reducer的作用就是设计state结构，它可以给定state 的初始值，更重要的是告诉store，根据对应的action如何更新state。 通常我们的store需要多个reducer组合，成为我们最后的state tree 注意点 保持reducer的纯净 通常我们的 reducer 是纯函数(pure function)即固定的输出，没有副作用，没有API请求… 等等，之后我们说为什么这么做。通常我们在处理业务中，比如请求一个列表的数据并渲染。 举个栗子： 12345678910111213141516171819const initialState = &#123; code: -1, data: [], isFetching: false&#125;;//初始化我们的state，也就是没有请求之前(view层没有派发 dispatch)，我们根据接口的数据格式做一个模拟function List(state = initialState, action) &#123; switch (action.type) &#123;// 这里的types 通常是我们保存这种常量的一个对象 case types.FETCH_LIST_SUCCESS: return &#123;...state, data:action.data,isFetching:false&#125;; case types.FETCHING_LIST: return &#123;...state, isFetching: true&#125; case types.FETCH_LIST_FAILURE: return &#123;...state, isFetching:false&#125;; default: return state &#125;&#125; 我们的reducer函数就是根据请求的状态返回不同的数据，但是数据格式是一定的。Fetching就是 请求过程中，比如我们做一个loading效果可能需要这个。然后type是success就是成功我们返回数据。这些请求都放到actions 中了，actions去处理逻辑，数据API，重组数据。只需要传给reducer函数数据结果就ok了。 为什么要重新返回一个对象 我们可以看到reducer函数在拿到数据后通过Object.assign 重新返回一个对象，直接state.data 修改，返回state不行吗？ 首先 我们默认的初始state是不能直接改变的，我们的reducer函数 在数据failure的时候 return了默认的state，这个initialState 是不应该被修改的。 另外，我们的react组件 会多次接受store传入props，每一次都应该是一个全新的对象引用，而不是同一个引用。比如我们需要比较两次传入的props，利用componentWillReciveProps（nextProps） 比较this.props 跟nextProps，肯定是需要两个对象空间的，不然是同一个对象引用也就没法比较了。 所以redux 中的reducer 函数要求我们必须返回新的对象state redux文档-reducer 多个reducer组合成我们的state tree通常我们会引入redux提供的一个函数 1import &#123; combineReducers &#125; from &apos;redux&apos; 其实combineReducers做的事情很简单，顾名思义就是合并多个reducer比如我们一个项目有多个reducer但是最后需要合并成一个，然后告诉store生成state tree，再注入Provider组件，先不关注Provider的问题。我们看一下combineReducers的简单实现 123456789101112//首先我们组合得到的reducer仍旧是一个函数//这个reducer会整合所有的reducer//然后根据我们定义的状态树的格式返回一个大的state tree// 根据reducers这个对象的key，取到reducer函数，并传入对应的 stateconst combineReducers = function combineReducers (reducers) &#123; return (state = &#123;&#125;, action) &#123; Object.keys(reducers).reduce((initialState, key) =&gt; &#123; initialState[key] = reducers[key](state[key], action) return initialState &#125;,&#123;&#125;) &#125;&#125; 这个函数返回一个rootReducer，然后createStore接收rootReducer，在createStore内部会调用一次dispatch(init)，rootReducer 会执行，所有我们制定的reducrs对象中的key 都会被添加到 一个初始化initialState中，遍历将每个子级state添加到initialState 。init的时候，state[key]是undefined，每个reducer函数有初始值 返回。以后的dispatch ，因为有了state tree，state[key]都可以取到值了。 待续…","categories":[{"name":"redux","slug":"redux","permalink":"http://yoursite.com/categories/redux/"}],"tags":[{"name":"redux解析","slug":"redux解析","permalink":"http://yoursite.com/tags/redux解析/"}]},{"title":"redux-devtools","slug":"redux-devtools","date":"2016-08-20T14:48:00.000Z","updated":"2017-06-18T10:54:16.146Z","comments":true,"path":"2016/08/20/redux-devtools/","link":"","permalink":"http://yoursite.com/2016/08/20/redux-devtools/","excerpt":"redux-devtools Introducingredux-devtools 是一个非常棒的工具，它可以让你实时的监控Redux的状态树的Store Installation","text":"redux-devtools Introducingredux-devtools 是一个非常棒的工具，它可以让你实时的监控Redux的状态树的Store Installation 123npm install --save-dev reux-devtoolsnpm install --save-dev redux-devtools-log-monitornpm install --save-dev redux-devtolls-dock-monitor Usege 创建DevTools组件在你的App项目中，通过“Monitor（监视显示）”用createDevTools创建一个DevTools组件。示例用了最常用，最简单的LogMonitor和DockMonitor containers/DevTools.js 1234567891011121314import React from &apos;react&apos;//从redux-devtools中引入createDevToolsimport &#123; createDevTools &#125; from &apos;redux-devtools&apos;;//显示包是单独的，要额外指定import LogMonitor from &apos;redux-devtools-log-monitor&apos;;import DockMonitor from &apos;redux-devtools-dock-monitor&apos;;//创建DevTools组件const DevTools = createDevTools( &lt;DockMonitor toggleVisibilityKey=&apos;ctrl-h&apos; changePositionKey =&apos;ctrl-q&apos;&gt; &lt;LogMonitor theme=&apos;tomorrow&apos; /&gt; &lt;/DockMonitor&gt;);export default DevTools 用DevTools.instrument()通过redux的compose来扩展store用createDevTools()创建的DevTools组件有个特殊的静态方法instrument(),它返回一个store的增强器,在开发中你需要在compose中使用。注意：DevTools.instrument()要放在applyMiddleware后，因为你的applyMiddleware可以存在异步行为，为了确保所有的actions显示在store中，所以要放在后面 store/create.js 123456789101112131415import &#123;createStore,applyMiddleware,compose&#125; from &apos;redux&apos;import rootReducer from &apos;./modules/reducers&apos;import thunk from &apos;./middleware/thunk&apos;import DevTools from &apos;../containers/DevTools&apos;const enhancer = compose( //你要使用的中间件，放在前面 applyMiddleware(thunk), //必须的！启用带有monitors（监视显示）的DevTools DevTools.instrument())export default function createStoreWithMiddleware(initialState)&#123; //注意：仅仅只有redux&gt;=3.1.0支持第三个参数 const store = createStore(rootReducer,initialState,enhancer) return store&#125; Render in your App 1234567891011121314151617import React from &apos;react&apos;;import &#123; render &#125; from &apos;react-dom&apos;;import &#123; Provider &#125; from &apos;react-redux&apos;;import configureStore from &apos;./store/configureStore&apos;;import TodoApp from &apos;./components/Counter&apos;;//注意，不要直接这样做，要区分开发环境和生产环境import DevTools from &apos;./containers/DevTools&apos;;const store = configureStore();render( &lt;Provider store=&#123;store&#125;&gt; &lt;div&gt; &lt;Counter /&gt; &lt;DevTools /&gt; &lt;/div&gt; &lt;/Provider&gt; document.getElementById(&apos;app&apos;));","categories":[{"name":"redux工具","slug":"redux工具","permalink":"http://yoursite.com/categories/redux工具/"}],"tags":[{"name":"redux工具","slug":"redux工具","permalink":"http://yoursite.com/tags/redux工具/"}]},{"title":"redux之store","slug":"redux之store","date":"2016-08-18T15:48:00.000Z","updated":"2017-06-18T10:54:16.144Z","comments":true,"path":"2016/08/18/redux之store/","link":"","permalink":"http://yoursite.com/2016/08/18/redux之store/","excerpt":"redux之storestore store是什么 store是一个管理集中式管理state的仓库其实就是一个大对象，并且提供了一系列的方法 123getState(), //返回statedispatch(action), //派发一个 actionsubscribe() //订阅监听","text":"redux之storestore store是什么 store是一个管理集中式管理state的仓库其实就是一个大对象，并且提供了一系列的方法 123getState(), //返回statedispatch(action), //派发一个 actionsubscribe() //订阅监听 通过redux提供的 createStore，传入reducer函数，我们可以得到一个store对象 12import &#123; createStore &#125; from &apos;redux&apos;;const store = createStore(reducer); 简单实现一个 createStore函数 123456789101112131415161718192021222324252627282930313233// 这是一个工厂函数，可以创建 storeconst createStore = (reducer) =&gt; &#123; let state; // 定义存储的state let listeners = []; // getState的作用很简单就是返回当前是state const getState = ()=&gt; state; //定义一个派发函数 //当在外界调用此函数的时候，会修改状态 const dispatch = (action)=&gt;&#123; //调用reducer函数修改状态，返回一新的状态并赋值给这个局部状态变量 state = reducer(state,action); //依次调用监听函数，通知所有的监听函数 listeners.forEach(listener =&gt; listener()); &#125; //订阅此状态的函数，当状态发生变化的时候记得调用此监听函数 const subscribe = function(listener)&#123; //先把此监听 加到数组中 listeners.push(listener); //返回一个函数，当调用它的时候将此监听函数从监听数组移除 return function()&#123; listeners = listeners.filter(l =&gt; l != listener); &#125; &#125; //默认调用一次dispatch给state赋一个初始值 dispatch(); return &#123; getState, dispatch, subscribe &#125;&#125;let store = createStore(reducer); 注意点 根据官方的说法，一个应用应该只有一个 store,即单一数据源，我们通过合并 reducer 来壮大state tree","categories":[{"name":"redux","slug":"redux","permalink":"http://yoursite.com/categories/redux/"}],"tags":[{"name":"redux解析","slug":"redux解析","permalink":"http://yoursite.com/tags/redux解析/"}]},{"title":"Promise笔记","slug":"Promise笔记","date":"2016-08-08T15:48:00.000Z","updated":"2017-06-18T10:56:27.202Z","comments":true,"path":"2016/08/08/Promise笔记/","link":"","permalink":"http://yoursite.com/2016/08/08/Promise笔记/","excerpt":"Promise笔记promise 为什么会有promise 根据官方的说法，promise的出现是为了解决 “callback hell”回调地狱，将横向的嵌套回调改为可以纵向以then的方法加载执行。","text":"Promise笔记promise 为什么会有promise 根据官方的说法，promise的出现是为了解决 “callback hell”回调地狱，将横向的嵌套回调改为可以纵向以then的方法加载执行。 简介&amp;用法 1234567891011121314// 通过new Promise 得到一个promise的实例，也就是一个普通对象。构造函数需要传一个callback 去定义何时执行resolve，reject 这两个函数var promise = new Promise(function(resolve, reject) &#123; if(&apos;code&apos;) &#123; // code 可能是异步操作成功判断条件 resolve() &#125; else &#123; reject() &#125;&#125;)// then的两个参数(resolve, reject)promise.then(function()&#123; console.log(&apos;success&apos;)&#125;,function()&#123; console.log(&apos;failure&apos;)&#125;) 三种状态 12[[PromiseValue]] //内部属性 -- 状态//而且这个状态不可随意更改，只跟resolve ，reject函数执行有关 实例内部有三种状态标示 Pending 进行中 即构造函数执行开始 Resolved 已成功 resolve函数 执行 Rejected 已失败 reject函数 执行 而且只能由Pending -&gt; Resolved,Pending -&gt; Rejected,即成功或失败 这个状态变化的条件是由我们控制的，一个请求返回成功状态码…等等 方法 Promise.prototype.then()两个参数 resolve， reject 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function getPromise (status) &#123; return new Promise(function(resolve, reject) &#123; let time = Date.now() console.log(&apos;time&apos;) setTimeout(()=&gt;&#123; if(status) &#123; resolve(time) &#125; else &#123; reject(new Error(&apos;status error&apos;)) &#125; &#125;,1000) &#125;)&#125;getPromise(1).then((time)=&gt;&#123; console.log(&apos;1&apos;,Date.now()-time) return Date.now()-time&#125;,(err)=&gt;&#123; console.log(err,&apos;err&apos;) return err&#125;).then((time)=&gt;&#123; console.log(&apos;2&apos;,time) return time&#125;,(err)=&gt;&#123; console.log(err,&apos;err&apos;) return err&#125;).then((time)=&gt;&#123; console.log(&apos;3&apos;,time)&#125;,(err)=&gt;&#123; console.log(err,&apos;err&apos;)&#125;)//&quot;time&quot;&quot;1&quot; 1002&quot;2&quot; 1002&quot;3&quot; 1002//// status传0getPromise(0).then((time)=&gt;&#123; console.log(&apos;1&apos;,Date.now()-time) return Date.now()-time&#125;).then((time)=&gt;&#123; console.log(&apos;2&apos;,time) return time&#125;,(err)=&gt;&#123; console.log(err) return err&#125;).then((time)=&gt;&#123; console.log(&apos;3&apos;,time)&#125;,(err)=&gt;&#123; console.log(err)&#125;)//&quot;time&quot;[object Error] &#123; ... &#125; &quot;err&quot;&quot;2&quot; [object Error] &#123; ... &#125;&quot;3&quot; [object Error] &#123; ... &#125;// 很有意思的是第一次promise 异步代码失败执行reject, 但是后面的都是执行resolve,而且resolve的参数都已经是error对象了 这里我们定义了一个函数来返回一个promise实例，然后实例可以执行then。只要构造函数执行，里面的代码就会执行，异步代码也会放到异步队列，当异步代码执行完(这里就是我们的setTimeout)，根据我们提供的条件，成功执行resolve，失败就reject。当然条件都是我们自己规定的，比如异步请求的code… 只要异步代码成功，我们的条件成功，就可以无限then。因为then传的resolve，reject 执行完都后，都会返回一个promise实例。另外，如果我们在resolve里return一个新的promise实例，那么这个promise实例将作为新的then的调用者。如果return一个非promise实例，都会作为参数传递给下面的resolve.. 无论是成功的结果还是error信息，都会被一级级传递下来。利用此，举个栗子我们有三个请求，每个请求的参数都依赖于上一个请求的结果，用promise就很简洁… 另外收集错误也是可以做到的。 举个栗子 123456789101112131415161718192021222324252627282930var getJson = function (url) &#123; return new Promise(function (resolve, reject) &#123; var xhr = new XMLHttpRequest () xhr.open(&apos;get&apos;,url) xhr.onreadystatechange = callback xhr.responseType = &apos;json&apos; xhr.send(null) function callback () &#123; if(this.readyState !== 4) return if(this.status === 200) &#123; resolve(this.response) &#125;else&#123; reject(new Error(this.statusText)) &#125; &#125; &#125;)&#125;getJson(&apos;api/list&apos;).then((response)=&gt;&#123; console.log(response) return getJson(response.url)&#125;,(err)=&gt;&#123; console.log(err) return err&#125;).then((response)=&gt;&#123; console.log(response)&#125;,(err)=&gt;&#123; console.log(err)&#125;)//这个就是典型的第二个请求的参数依赖于第一个请求返回的结果。业务中还有那种比如两三个请求都成功了，我们才处理，渲染的。用promise都比较好处理 Promise.prototype.catch()Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 123456789101112getPromise(0).then((time)=&gt;&#123; console.log(&apos;1&apos;,Date.now()-time) return Date.now()-time&#125;,(err)=&gt;&#123; console.log(err,&apos;err&apos;) return err&#125;).then(null,(err)=&gt;&#123; console.log(err,&apos;err&apos;) return err&#125;).then(null,(err)=&gt;&#123; console.log(err,&apos;err&apos;)&#125;) 类似于我们上面的例子把后面两个then 的 resolve去掉 改为null.也就是说，当我们需要在第二个then 里面有目的的收集错误的时候，我们可以直接用catch方法，省去then写法的麻烦。类似于这样 123456789101112getPromise(0).then((time)=&gt;&#123; console.log(&apos;1&apos;,Date.now()-time) return Date.now()-time&#125;,(err)=&gt;&#123; console.log(err,&apos;err&apos;) return err&#125;).catch((err)=&gt;&#123; console.log(err,&apos;err&apos;) return err&#125;).catch((err)=&gt;&#123; console.log(err,&apos;err&apos;)&#125;) 当然我们不会写两个catch。这里只是改写一下then。更多详细的直接看es6 入门里面，讲的很详细，因为catch我用的也不是很多 es6入门阮一峰-promise Promise.all()all 的主要用途就是多个请求，同时成功了，再做某事参数是一个数组，数组里面是Promise实例 注意这个方法是构造函数上的方法，用于将多个Promise实例，包装成一个新的Promise实例 1234两个Promise，请求 1.getExams 2.getQuestionPromise.all([getExams(examId), getQuestion(questionId)]).then((exams,questions)=&gt;&#123; console.log(exams,questions)&#125;) 应用场景就是我们多个请求都成功，才能做什么。 Promise.race()跟all用法类似，都是传多个promise对象。根据race 的意思，我们大概知道是干嘛的了。哪个先完成，就返回哪个的数据。应用场景大概是两个服务器，比较哪个快。但是现在服务器 都会通过nginx 做负载均衡，也不需要前端去关注这些东西。 123Promise.race([getExams(examId), getQuestion(questionId)]).then((data)=&gt;&#123; console.log(data)&#125;) 本次笔记记录先到此，其实API 书中都比较清楚了。关键还是项目中的应用。接下来还会去探究promise内部的实现。 自己实现类fetch的方法 推荐链接 es6入门阮一峰-promisejavascript标准参考教材剖析Promise内部结构","categories":[{"name":"js中的观察者模式","slug":"js中的观察者模式","permalink":"http://yoursite.com/categories/js中的观察者模式/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"原生js","slug":"原生js","permalink":"http://yoursite.com/tags/原生js/"}]},{"title":"js中的观察者模式","slug":"js中的观察者模式","date":"2016-07-19T06:48:00.000Z","updated":"2017-06-18T10:32:41.611Z","comments":true,"path":"2016/07/19/js中的观察者模式/","link":"","permalink":"http://yoursite.com/2016/07/19/js中的观察者模式/","excerpt":"观察者模式 简介 观察者模式又称发布订阅模式，是一种最常用的设计模式之一了。讲道理，如果我们写的不是稍微底层的代码，可能不会用到它。 但是有了它让代码更加灵活，更加规整，减少沉余代码，方便分模块，分功能开发。","text":"观察者模式 简介 观察者模式又称发布订阅模式，是一种最常用的设计模式之一了。讲道理，如果我们写的不是稍微底层的代码，可能不会用到它。 但是有了它让代码更加灵活，更加规整，减少沉余代码，方便分模块，分功能开发。 引入 在前端业务中，可能用的比较多的地方可能就是添加事件了。其实浏览器的事件也是观察者模式 123div.onclick = function click()&#123; console(&apos;click&apos;)&#125; 这里function click 订阅了 div 的click事件，当我们的鼠标点击操作，事件发布，对应的 function 就会执行。这个 function click就是一个观察者。 具象化理解 其实单纯的看代码实现，也可以理解。但是万物都是有联系的，这些编程模式设计之初也是来源于生活经验吧，所以，具象的理解也是很重要的体验。 我们举一个结婚办酒席的例子。比如你的一个好朋友要结婚了，’结婚’这件事情不是天天发生，一辈子就那么一… 两次(maybe more)，所以我们的’去参加他的婚礼’肯定不是天天发生，只是在特定的时候。我肯定不能天天去问他，’今天你结婚吗，我来参加酒席啊’。一次两次还行，天天问，sb啊。假如是一个找不到对象的单身汪，被你天天这么问，还不得杀了你。。 那这里就需要有一个事件发布了，也就是‘通知你’。 我作为一个观察者，去订阅他’结婚’ 的这个事件，就是我们是好朋友，他的婚礼我肯定去，我们已经说好了。那么我就是观察者，’我去参加婚礼’就是对应而来的动作。当我订阅了’结婚’ 这个事件，我就不需要天天去问他了，我该干嘛干嘛，该去泡妞，约饭，看电影，约… 就干嘛。 当他发布’结婚’ 这个事件，通知到我了，我就在特定的时候，去do’参加婚礼酒席’这个行为function … 123456789// 模拟代码// 我订阅了&apos;marry&apos; 事件we.on(&apos;marry&apos;,function()&#123; // 去参加婚礼酒席&#125;)// 然后他发布。比如浏览器的点击// 对应的我的 function 就会执行 解耦/模块/功能 其实在代码中是需要一个类似于中间服务的,管理发布订阅的中间者。比如浏览器中的事件处理程序，他提供了订阅的接口，然后接收’事件’ 信号 发布给你。让js代码跟浏览器之间有了联系，互动。而本来是两个不同的东西。 在我看来，观察者模式最大的好处就是在于解耦，会让我们一锅端的代码，分功能，分模块的抽离开，更加清晰，开发成本变低，也容易维护。比如： 我们项目里的view 展示层跟model(数据处理)逻辑层，最开始写页面，ajax，字符串拼接，请求回一个接口拼一下，然后给dom。可能我们一个js文件，一个function里面又请求了接口数据，又去负责 view 的展示。 123456789101112131415161718// 请求function getData () &#123; var xhr = new XMLHttpRequest () xhr.open(&apos;get&apos;,url) xhr.onreadystatechange = function () &#123; if(this.readyState !== 4) return if(this.status === 200) &#123; this.emit(&apos;渲染&apos;) // 发布 &#125; &#125; xhr.responseType = &apos;json&apos; xhr.send(null)&#125;//渲染function view () &#123;&#125;xhr.on(&apos;渲染&apos;,view) 直接在状态码200那里放个callback，也能做到。但是，如果我有两个渲染函数，处理不同的东西，我每次还要改成不同的函数吗。 这个相同请求的过程是不是还要写一遍。用观察者的话 123456789101112function view1 ()&#123;&#125;function view2 ()&#123;&#125;function view3 ()&#123;&#125;function view4 ()&#123;&#125;if(我要渲染view1)&#123; xhr.on(&apos;渲染&apos;,view1) //订阅 xhr.on(&apos;渲染&apos;,view2)&#125;else&#123; xhr.on(&apos;渲染&apos;,view3)； xhr.on(&apos;渲染&apos;,view4)；&#125; 好处就在于我的getData这个功能，方法就只负责请求数据，然后他会暴露一个接口，供我去添加方法。这样我的getData 就相对来说是比较完整的功能模块，就算我有再多的情况，我的getData 里面的代码是不会改动的了。 时候我们经常为了实现业务，添加一个新的功能，而去更改我们之前写好的代码，导致我们本来的功能模块被改的面目全非。而且会有好多的重复代码。过程？ or 模块？ 当然封好一个好的完整的功能模块是挺难的一件事情，但我们起码要有一个开始。 订阅去添加方法，发布了事件池就执行。 MV*类框架 MVC也是一种设计模式，这里面也都应用了观察者。他内部也都是各种发布订阅，好像是一个观察者模型，从而实现了一个模拟的内存中的 dom 改变，计算出那个 DOM 节点应该改变。当然具体实现要做好多事情…就不… redux 简单实现一个createStore函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 这是一个工厂函数，可以创建 storeconst createStore = (reducer) =&gt;&#123; let state; // 定义存储的 state let listeners = []; // getState 的作用很简单就是返回当前是 state const getState = () =&gt; state; // 定义一个派发函数 // 当在外界调用此函数的时候，会修改状态 const dispatch = (action) =&gt;&#123; // 调用 reducer 函数修改状态，返回一新的状态并赋值给这个局部状态变量 state = reducer(state,action); // 依次调用监听函数，通知所有的监听函数 listeners.forEach(l =&gt; l()); &#125; // 订阅此状态的函数，当状态发生变化的时候记得调用此监听函数 const subscribe = function(listener)&#123; // 先把此监听 加到数组中 listeners.push(listener); // 返回一个函数，当调用它的时候将此监听函数从监听数组移除 return function()&#123; listeners = listeners.filter(l =&gt; 1 != listener); &#125; &#125; // 默认调用一次dispatch 给 state 赋一个初始值 dispatch(); return &#123; getState, dispatch, subscribe &#125;&#125;let store = createStore(reducer);// 把数据渲染到界面上const render = () =&gt;&#123; document.body.innerText = state.getState();&#125;// 订阅状态变化事件，当状态变化时用监听函数store.subscribe(render);render();var INCREASE_ACTION = &#123;type: &apos;INCREMENT&apos;&#125;;document.addEventListener(&apos;click&apos;, function (e) &#123; //触发一个Action store.dispatch(INCREASE_ACTION);&#125;) 在node中的作用大多数时候我们不会直接使用 EventEmitter,而是在对象中继承它。包括fs、net、http在内的，只要是支持事件响应的核心模块都是 EventEmitter的子类。 实现一个可以发布订阅的类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&apos;use strict&apos;class EmitterEvent&#123; constructor()&#123; // 构造器。实例上创建一个事件池 this._event = &#123;&#125; &#125; // on 订阅 on (eventName,handler)&#123; // 根据 eventName,事件池中有对应的事件数组，就 push 添加，没有就新建一个。 if(typeof handler === &apos;function&apos;)&#123; if(this._event[eventName])&#123; this._event[eventName].push(handler); &#125;else&#123; this._event[eventName] = [handler] &#125; &#125; &#125; emit (eventName)&#123; // 根据 eventName找到对应数组 var events = this._event[eventName]; // 取一下传进来的参数，方便给执行的函数 var otherArgs = Array.prototype.slice.call(arguments,1); var that = this; if(events)&#123; events.forEach((event) =&gt;&#123; event.apply(that,otherArgs); &#125;) &#125; &#125; // 解除订阅 off (eventName,handler)&#123; var events = this._event[eventName]; if(events)&#123; this._event[eventName] = events.filter((event) =&gt;&#123; return event !== handler; &#125;) &#125; &#125; // 订阅以后，emit 发布执行一次后自动解除订阅once (eventName,handler)&#123; var that = this; function func ()&#123; var args = Array.prototype.slice.call(arguments,0); handler.apply(that,args); this.off(eventName,func); &#125; this.on(eventName,func);&#125;var event = new EmitterEvent()function a (something) &#123; console.log(something,&apos;aa-aa&apos;)&#125;function b (something) &#123; console.log(something)&#125; event.once(&apos;dosomething&apos;,a) event.emit(&apos;dosomething&apos;, &apos;chifan&apos;) 当我们需要用的时候，只需要继承一下这个EmitterEvent类。要操作的实例就可以用on,emit方法，也就是可以用发布订阅。比如XHR，组件…","categories":[{"name":"js中的观察者模式","slug":"js中的观察者模式","permalink":"http://yoursite.com/categories/js中的观察者模式/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"原生js","slug":"原生js","permalink":"http://yoursite.com/tags/原生js/"}]},{"title":"BFC","slug":"BFC","date":"2016-05-13T04:43:00.000Z","updated":"2017-06-18T10:07:22.812Z","comments":true,"path":"2016/05/13/BFC/","link":"","permalink":"http://yoursite.com/2016/05/13/BFC/","excerpt":"BFCBFC( Block Formatting Context ) 直译为 “块级格式化范围”。 是 W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。","text":"BFCBFC( Block Formatting Context ) 直译为 “块级格式化范围”。 是 W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成 BFC，浮动元素内部子元素主要受该浮动元素影响，两个浮动元素之间是互不影响的。这里有点类似一个 BFC 就是一个独立的行政单位的意思。 也可以说 BFC 就是一个作用范围。可以把它理解是一个独立的容器，并且这个容器里的box的布局，与这个容器外的毫不相干。 BFC 的特征： 内部的Box会垂直方向，一个接一个地放置。 Box垂直方向的距离由 margin 决定。属于同一个BFC的两个相邻 Box 的margin会发生重叠 每个元素的 margin box的左边，与包含块 border box的左边相接触（对于从左往右的格式化，否则相反）。即使存在浮动也是如此。 BFC的区域不会与float box重叠 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算 BFC 的高度时，浮动元素也参与计算 BFC 的应用场景有哪些？如何触发 BFC？满足下列条件中至少一项，即可触发 BFC： float 的值不为 none position 的值不为 static 或者 relative. display 的值为 table-cell,table-caption,inline-block,flex, 或者 inline-flex中的其中一个。 overflow的值不为 visible。 BFC 的应用场景：1.解决 margin 叠加问题： 1234&lt;div class=&quot;first-block&quot;&gt;&lt;/div&gt;&lt;div class=&quot;second-block&quot;&gt; &lt;h2&gt;DDFE&lt;/h2&gt;&lt;/div&gt; 1234567891011121314151617181920212223html,body,div,h2&#123; margin: 0; padding: 0; &#125; body&#123; padding: 30px; &#125; div&#123; margin-left: 100px; &#125; .first-block&#123; width: 200px; height: 200px; background-color: #BE4F4F; &#125; .second-block&#123; width: 200px; height: 200px; background-color: #5A6A94; &#125; .second-block h2&#123; margin: 20px; &#125; 很简单是吧，浏览器中的效果是这样的： 原因是： 外边距折叠，这个间距是 h2的上边距引起的。 css 里面关于折叠的条件: 两个块元素产生 折叠现象，必须满足一个必备条件：这两个元素的 margin 必须是相邻的；那么如果定义相邻呢，w3c规范，两个 margin 是临接的必须满足以下条件： 必须是处于常规文档流（ 非float和绝对定位 ）的块级盒子，并且处于同一个 BFC 当中。 没有 inline 盒子，没有空隙，没有 padding 和 border 将他们分隔开。 都属于垂直方向上相邻的外边距，可以是下面任意一种情况： 那么我们就可以通过给元素叫边框或者边距来解决啦，我是不是很聪明呢? 解决方法1: 123456.second-block&#123; width: 200px; height: 200px; border: 1px solid rgba(0,0,0,0); background-color: #5A6A94;&#125; 折叠问题解决了，但是由于有1px的边框， second-block 看起来会比 first-block 宽一点，没关系，添加 box-sizeing: border-box 属性可以解决这个问题 解决办法2: 123456.second-block&#123; width: 200px; height: 200px; background-color: #5A6A94; overflow: hidden;&#125; 通过把 overflow 把 second-block 元素形成一个 BFC，完美解决! 2.用于布局 杯布局和双飞翼布局，他们的都要求三列布局，中间宽度自适应，两边定宽，这样做的优势是重要的东西在文档流前面可以优先渲染。 小洋子，就是这样: 老规矩先贴上代码: html 部分: 12345&lt;div class=&quot;container clearfix&quot;&gt; &lt;div class=&quot;meddle&quot;&gt;iconWave&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;iconWave&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;iconWave&lt;/div&gt;&lt;/div&gt; css部分: 12345678910111213141516171819202122232425262728293031323334353637383940html,body,div&#123; margin: 0; padding: 0;&#125;.clearfix:after&#123; content: &apos;&apos;; display: block; height: 0; clear: both; visibility: hidden;&#125;.container&#123; padding: 0 200px; font-size: 25px;&#125;.left&#123; position: relative; float: left; width: 200px; height: 1000px; margin-left: -100%; left: -200px; background: orange;&#125;.meddle&#123; width: 100%; height: 1000px; background: blue; float: left; position: relative;&#125;.right&#123; width: 200px; height: 1000px; background-color: orange; float: left; position: relative; margin-left: -200px; right: -200px;&#125; 解析： html代码中，middle部分首先要放在 container 的最前面部分，然后是 left,right。 将三者都设置 float:left, posotion: relative。 middle设置 width: 100% 占满一行 此时 middle 占满一行，所以要把 left 拉到 middle 所在行的最左边，使用margin-lft: -100%。 这时 left 拉到 middle 所在行的最左边，但会覆盖 middle 内容的左端，要把 middle 内容拉出来，所以在外围 container 加上 padding:0 200px; middle 内容拉出来了，但 left 也跟着出来了，所以要还原，就对 left 使用相对定位 left: -200px 同理，right要拉到 middle 所在行的最右边，使用 margin-left: -200px,right: -200px。 其实除了圣杯布局还有一个双飞翼布局，双飞翼布局是对圣杯布局的一种改良，多一个div就可以不用相对布局了，只用到了浮动和负边距。 DOM结构： container内层增加一个div 1234567&lt;div class=&quot;container clearfix&quot;&gt; &lt;div class=&quot;meddle&quot;&gt; &lt;div class=&quot;inner&quot;&gt;iconWave&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;left&quot;&gt;iconWave&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;iconWave&lt;/div&gt;&lt;/div&gt; 样式： 去掉左右栏的相对定位，去掉包裹层padding,以中间栏新增div的margin代替 1234567891011121314151617181920212223242526272829303132333435363738* &#123; margin: 0; padding: 0; &#125; .cleanfix &#123; clear: both; &#125; .cleanfix:after &#123; content: &apos;.&apos;; clear: both; display: block; visibility: hidden; height: 0; zoom: 1; &#125; .left, .right, .meddle &#123; float: left; &#125; .left&#123; width: 200px; height: 1000px; background-color: #BE4F4F; margin-left: -100%; &#125; .meddle&#123; width: 100%; &#125; .meddle .inner&#123; margin: 0 200px; height: 1000px; background-color: lime; &#125; .right&#123; width: 200px; height: 1000px; background-color: aqua; margin-left: -200px; &#125; 3.用于清除浮动，计算 BFC 高度举个例子： 123456789101112131415161718192021html,body,div&#123; margin: 0; padding: 0; &#125; .container&#123; border: 10px solid blue; width: 880px; margin: 50px; overflow: hidden; &#125; .left,.meddle1,.meddle2,.right&#123; background: pink; width: 200px; height: 200px; line-height: 200px; text-align: center; float: left; font-size: 80px; color: #666; margin: 10px; &#125; 123456&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;W&lt;/div&gt; &lt;div class=&quot;meddle1&quot;&gt;a&lt;/div&gt; &lt;div class=&quot;meddle2&quot;&gt;v&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;e&lt;/div&gt;&lt;/div&gt; 我感性的认为是这个样子： 实际上是这个样子： div 标签没有包住 ul 标签，原因很简单：container 下的子元素浮动了，因此div的高度就塌陷了。要解决塌陷，就得清除浮动。 清除浮动就两种方式： 1） 利用 clear 属性清除浮动 12345678.clearfix:after&#123; content: &apos;&apos;; display: block; height: 0; clear: both; visibility: hidden; zoom: 0; &#125; 2)使父容器形成 BFC。 给父元素 .container 加一句 overflow: hidden 触发 bfc。","categories":[{"name":"js中的观察者模式","slug":"js中的观察者模式","permalink":"http://yoursite.com/categories/js中的观察者模式/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"CSS基础","slug":"CSS基础","permalink":"http://yoursite.com/tags/CSS基础/"}]}]}