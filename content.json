{"meta":{"title":"iconWave","subtitle":"web and poetry","description":"人生除了代码还有诗和远方。","author":"iconWave","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2015-10-19T22:49:50.000Z","updated":"2017-06-14T08:25:58.463Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2015-10-19T22:49:50.000Z","updated":"2017-06-14T08:10:12.638Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"我来了我看到了，我征服啦!","slug":"hello-world","date":"2017-06-14T02:47:34.092Z","updated":"2017-06-14T08:28:59.883Z","comments":true,"path":"2017/06/14/hello-world/","link":"","permalink":"http://yoursite.com/2017/06/14/hello-world/","excerpt":"","text":"title: Hello WorldWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"cate","slug":"cate","permalink":"http://yoursite.com/categories/cate/"}],"tags":[{"name":"设计","slug":"设计","permalink":"http://yoursite.com/tags/设计/"},{"name":"杂谈","slug":"杂谈","permalink":"http://yoursite.com/tags/杂谈/"}]},{"title":"我来了我看到了，我征服啦!","slug":"test","date":"2016-11-19T02:44:25.000Z","updated":"2017-06-18T09:19:44.590Z","comments":true,"path":"2016/11/19/test/","link":"","permalink":"http://yoursite.com/2016/11/19/test/","excerpt":"","text":"我来了我看到了，我征服啦！Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"cate","slug":"cate","permalink":"http://yoursite.com/categories/cate/"}],"tags":[{"name":"设计","slug":"设计","permalink":"http://yoursite.com/tags/设计/"},{"name":"杂谈","slug":"杂谈","permalink":"http://yoursite.com/tags/杂谈/"}]},{"title":"js中的观察者模式","slug":"js中的观察者模式","date":"2016-07-19T06:48:00.000Z","updated":"2017-06-18T09:31:34.797Z","comments":true,"path":"2016/07/19/js中的观察者模式/","link":"","permalink":"http://yoursite.com/2016/07/19/js中的观察者模式/","excerpt":"","text":"观察者模式 简介 观察者模式又称发布订阅模式，是一种最常用的设计模式之一了。讲道理，如果我们写的不是稍微底层的代码，可能不会用到它。 但是有了它让代码更加灵活，更加规整，减少沉余代码，方便分模块，分功能开发。 引入 在前端业务中，可能用的比较多的地方可能就是添加事件了。其实浏览器的事件也是观察者模式 123div.onclick = function click()&#123; console(&apos;click&apos;)&#125; 这里function click 订阅了 div 的click事件，当我们的鼠标点击操作，事件发布，对应的 function 就会执行。这个 function click就是一个观察者。 具象化理解 其实单纯的看代码实现，也可以理解。但是万物都是有联系的，这些编程模式设计之初也是来源于生活经验吧，所以，具象的理解也是很重要的体验。 我们举一个结婚办酒席的例子。比如你的一个好朋友要结婚了，’结婚’这件事情不是天天发生，一辈子就那么一… 两次(maybe more)，所以我们的’去参加他的婚礼’肯定不是天天发生，只是在特定的时候。我肯定不能天天去问他，’今天你结婚吗，我来参加酒席啊’。一次两次还行，天天问，sb啊。假如是一个找不到对象的单身汪，被你天天这么问，还不得杀了你。。 那这里就需要有一个事件发布了，也就是‘通知你’。 我作为一个观察者，去订阅他’结婚’ 的这个事件，就是我们是好朋友，他的婚礼我肯定去，我们已经说好了。那么我就是观察者，’我去参加婚礼’就是对应而来的动作。当我订阅了’结婚’ 这个事件，我就不需要天天去问他了，我该干嘛干嘛，该去泡妞，约饭，看电影，约… 就干嘛。 当他发布’结婚’ 这个事件，通知到我了，我就在特定的时候，去do’参加婚礼酒席’这个行为function … 123456789// 模拟代码// 我订阅了&apos;marry&apos; 事件we.on(&apos;marry&apos;,function()&#123; // 去参加婚礼酒席&#125;)// 然后他发布。比如浏览器的点击// 对应的我的 function 就会执行 解耦/模块/功能 其实在代码中是需要一个类似于中间服务的,管理发布订阅的中间者。比如浏览器中的事件处理程序，他提供了订阅的接口，然后接收’事件’ 信号 发布给你。让js代码跟浏览器之间有了联系，互动。而本来是两个不同的东西。 在我看来，观察者模式最大的好处就是在于解耦，会让我们一锅端的代码，分功能，分模块的抽离开，更加清晰，开发成本变低，也容易维护。比如： 我们项目里的view 展示层跟model(数据处理)逻辑层，最开始写页面，ajax，字符串拼接，请求回一个接口拼一下，然后给dom。可能我们一个js文件，一个function里面又请求了接口数据，又去负责 view 的展示。 123456789101112131415161718// 请求function getData () &#123; var xhr = new XMLHttpRequest () xhr.open(&apos;get&apos;,url) xhr.onreadystatechange = function () &#123; if(this.readyState !== 4) return if(this.status === 200) &#123; this.emit(&apos;渲染&apos;) // 发布 &#125; &#125; xhr.responseType = &apos;json&apos; xhr.send(null)&#125;//渲染function view () &#123;&#125;xhr.on(&apos;渲染&apos;,view) 直接在状态码200那里放个callback，也能做到。但是，如果我有两个渲染函数，处理不同的东西，我每次还要改成不同的函数吗。 这个相同请求的过程是不是还要写一遍。用观察者的话 123456789101112function view1 ()&#123;&#125;function view2 ()&#123;&#125;function view3 ()&#123;&#125;function view4 ()&#123;&#125;if(我要渲染view1)&#123; xhr.on(&apos;渲染&apos;,view1) //订阅 xhr.on(&apos;渲染&apos;,view2)&#125;else&#123; xhr.on(&apos;渲染&apos;,view3)； xhr.on(&apos;渲染&apos;,view4)；&#125; 好处就在于我的getData这个功能，方法就只负责请求数据，然后他会暴露一个接口，供我去添加方法。这样我的getData 就相对来说是比较完整的功能模块，就算我有再多的情况，我的getData 里面的代码是不会改动的了。 时候我们经常为了实现业务，添加一个新的功能，而去更改我们之前写好的代码，导致我们本来的功能模块被改的面目全非。而且会有好多的重复代码。过程？ or 模块？ 当然封好一个好的完整的功能模块是挺难的一件事情，但我们起码要有一个开始。 订阅去添加方法，发布了事件池就执行。 MV*类框架 MVC也是一种设计模式，这里面也都应用了观察者。他内部也都是各种发布订阅，好像是一个观察者模型，从而实现了一个模拟的内存中的 dom 改变，计算出那个 DOM 节点应该改变。当然具体实现要做好多事情…就不… redux 简单实现一个createStore函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 这是一个工厂函数，可以创建 storeconst createStore = (reducer) =&gt;&#123; let state; // 定义存储的 state let listeners = []; // getState 的作用很简单就是返回当前是 state const getState = () =&gt; state; // 定义一个派发函数 // 当在外界调用此函数的时候，会修改状态 const dispatch = (action) =&gt;&#123; // 调用 reducer 函数修改状态，返回一新的状态并赋值给这个局部状态变量 state = reducer(state,action); // 依次调用监听函数，通知所有的监听函数 listeners.forEach(l =&gt; l()); &#125; // 订阅此状态的函数，当状态发生变化的时候记得调用此监听函数 const subscribe = function(listener)&#123; // 先把此监听 加到数组中 listeners.push(listener); // 返回一个函数，当调用它的时候将此监听函数从监听数组移除 return function()&#123; listeners = listeners.filter(l =&gt; 1 != listener); &#125; &#125; // 默认调用一次dispatch 给 state 赋一个初始值 dispatch(); return &#123; getState, dispatch, subscribe &#125;&#125;let store = createStore(reducer);// 把数据渲染到界面上const render = () =&gt;&#123; document.body.innerText = state.getState();&#125;// 订阅状态变化事件，当状态变化时用监听函数store.subscribe(render);render();var INCREASE_ACTION = &#123;type: &apos;INCREMENT&apos;&#125;;document.addEventListener(&apos;click&apos;, function (e) &#123; //触发一个Action store.dispatch(INCREASE_ACTION);&#125;) 在node中的作用大多数时候我们不会直接使用 EventEmitter,而是在对象中继承它。包括fs、net、http在内的，只要是支持事件响应的核心模块都是 EventEmitter的子类。 实现一个可以发布订阅的类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&apos;use strict&apos;class EmitterEvent&#123; constructor()&#123; // 构造器。实例上创建一个事件池 this._event = &#123;&#125; &#125; // on 订阅 on (eventName,handler)&#123; // 根据 eventName,事件池中有对应的事件数组，就 push 添加，没有就新建一个。 if(typeof handler === &apos;function&apos;)&#123; if(this._event[eventName])&#123; this._event[eventName].push(handler); &#125;else&#123; this._event[eventName] = [handler] &#125; &#125; &#125; emit (eventName)&#123; // 根据 eventName找到对应数组 var events = this._event[eventName]; // 取一下传进来的参数，方便给执行的函数 var otherArgs = Array.prototype.slice.call(arguments,1); var that = this; if(events)&#123; events.forEach((event) =&gt;&#123; event.apply(that,otherArgs); &#125;) &#125; &#125; // 解除订阅 off (eventName,handler)&#123; var events = this._event[eventName]; if(events)&#123; this._event[eventName] = events.filter((event) =&gt;&#123; return event !== handler; &#125;) &#125; &#125; // 订阅以后，emit 发布执行一次后自动解除订阅once (eventName,handler)&#123; var that = this; function func ()&#123; var args = Array.prototype.slice.call(arguments,0); handler.apply(that,args); this.off(eventName,func); &#125; this.on(eventName,func);&#125;var event = new EmitterEvent()function a (something) &#123; console.log(something,&apos;aa-aa&apos;)&#125;function b (something) &#123; console.log(something)&#125; event.once(&apos;dosomething&apos;,a) event.emit(&apos;dosomething&apos;, &apos;chifan&apos;) 当我们需要用的时候，只需要继承一下这个EmitterEvent类。要操作的实例就可以用on,emit方法，也就是可以用发布订阅。比如XHR，组件…","categories":[{"name":"cate","slug":"cate","permalink":"http://yoursite.com/categories/cate/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"原生js","slug":"原生js","permalink":"http://yoursite.com/tags/原生js/"}]}]}